; - Титков Н.А А-07-21
; - Вариант 15
; - 15. Написать программу, удаляющую из исходной строки многократные вхождения  заданного символа, заменяя их однократными, Z-string

.model small
.stack 100h

.data
    MaxMsgLen       equ 255
    sourceString    db "aabbbccdddeeebbbbbbbbbbbff",13,10, 0,"dsadasfaddfgsdgsfag",0  ; Исходная строка с завершающим нулевым символом
    resultString    db MaxMsgLen dup (?)                                              ; Новая строка объявлена с максимальной длиной 255 символов
	charToDelete    db 'b'                                                            ; Заданный Символ, который нужно удалить при многократном вхождении

.code
main:
;============================================================================================================
    mov ax, @data
    mov ds, ax                    ; настройка DS на начало сегмента данных
	mov es, ax                    ; настройка ES на начало сегмента данных

    mov si, offset sourceString   ; Устанавливаем источник данных для вывода (исходная строка)
	call PrintString              ; Вызов процедуры PrintString для вывода строки
	mov si, offset sourceString   ; Устанавливаем источник данных (исходная строка)
    mov di, offset resultString   ; Устанавливаем приемник данных (новая строка для результата)
	
	mov bl, charToDelete          ; Загружаем символ, который нужно удалять в BL
;============================================================================================================
	CLD                           ; Обнуляем флаг
	xor cx,cx                     ; Обнуляем регистр для подсчета кол-во повторов
replace_duplicates:
    mov al, [si]                  ; Загружаем текущий символ из исходной строки в AL
    cmp al, 0                     ; Проверяем, достигли ли конца строки (нулевого символа)
    je end_of_string              ; Если достигли конца строки, завершаем цикл

    cmp al, bl                    ; Сравниваем текущий символ с символом для удаления
    je skip_char                  ; Если символ совпадает, проверяем его на повтор
    
	xor cx,cx                     ; Обнуляем регистр для подсчета кол-во повторов, т.к встретился другой символ
    movsb                         ; Копируем символ
jmp replace_duplicates

skip_char:
	cmp cx, 0                     ; Проверяем встречался ли символ до этого
	jnz next                      ; Если да то не выводим
	stosb                         ; Если нет то переносим 
next:	
    inc cx                        ; Считаем кол-во повторов
    inc si                        ; Увеличиваем указатель источника
    jmp replace_duplicates        ; Переходим к следующему символу
;============================================================================================================
end_of_string:
    mov byte ptr [di], 0          ; Устанавливаем нулевой символ в конце новой строки для результата
	mov si, offset resultString   ; Устанавливаем источник данных для вывода (исходная строка)
	call PrintString              ; Вызов процедуры PrintString для вывода строки
	
    mov ax , 4C00h                ; Функция завершения программы 
    int 21h                       ; Вызов прерывания для завершения программы

;============================================================================================================
PrintString proc
    mov ah, 0Eh                   ; Установка функции вывода одного символа
print_loop:
    lodsb                         ; Загрузка символа из строки, инкремент si
    cmp al, 0                     ; Проверка на нулевой символ (конец строки)
    jz done                       ; Если нулевой символ, завершаем вывод

    int 10h                       ; Вывод символа
    jmp print_loop                ; Переход на следующий символ

done:
    ret                           ; Возврат из процедуры

PrintString endp

end main
