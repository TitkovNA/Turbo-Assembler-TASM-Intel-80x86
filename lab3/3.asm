
; - Титков Н.А А-07-21
; - Вариант 15
; - Задан массив указателей на однобайтовые числа со знаком. Заменить все указатели на числа меньше -15 на нулевые указатели.

.model small
.stack 200h

.data
array dw num1, num2, num3, num4, num5 ; объявление массива
num1 db -16
num2 db 90
num3 db 25
num4 db -5
num5 db -15
count equ 5
output_msg db 13, 10, "Numbers after processing:", 13, 10, "$"
neg_msg db "-$"

.code
main proc
;----------------------------------------------------------------------------
; Начальная инициализация
	xor ax,ax
	xor bx,bx
	xor cx,cx
	xor dx,dx
    mov ax, @data
    mov ds, ax ; настройка DS на начало сегмента данных
	
;----------------------------------------------------------------------------
    ; Выводим заголовок сообщения
    lea dx, output_msg
    mov ah, 09h
    int 21h
;----------------------------------------------------------------------------
;Заменить все указатели на числа меньше -15 на нулевые указатели

mov cx, count ; Устанавливаем счетчик на количество элементов массива
mov si, offset array ; Загружаем адрес массива в регистр SI

search_loop:
	
    mov bx, [si]             ; Загружаем указатель на чsисло в регистр bx
    ;mov al, [bx]             ; Загружаем значение числа
    cmp byte ptr [bx], -15              ; Сравниваем число с -15
    jg metka   
	mov byte ptr [si], 1
metka:
    add si, 2                ; Переходим к следующему указателю в массиве
    loop search_loop         ; Повторяем цикл
 
;----------------------------------------------------------------------------
	; Выводим элементы массива на экран
    mov cx, count ; Устанавливаем счетчик на количество элементов массива
	lea si, array ; Загружаем адрес массива в регистр SI
    
print_loop:
;----------------------------------------------------------------------------
	;Работа со знаком
    mov bx, [si]; Загружаем текущий элемент массива (смещение)
    mov al, [bx] ; Загружаем число из памяти, на которое указывает смещение
    cmp al, 0 ; Проверяем знак числа
    jns print_positive ; Если неотрицательное, переходим к выводу
    ; Иначе выводим знак минус
    lea dx, neg_msg
    mov ah, 09h
    int 21h
    ; Преобразуем число в положительное и выводим
    neg al ; Инвертируем биты числа
    jmp print_number

print_positive:
    jmp print_number

print_number:
;----------------------------------------------------------------------------
    ; Преобразуем число в ASCII-код символа
	
    mov ah, 00h ; Обнуляем старший байт
    mov bh, 10 ; Делитель для десятичного преобразования

    xor bl, bl ; Сбрасываем счетчик цифр в числе
    
divide_loop:
    div bh ; Делим Ax на 10
    push ax ; Сохраняем результат деления в стеке
    inc bl ; Увеличиваем счетчик цифр
    cmp al, 10 ; Проверяем, закончили ли деление
	jge divide_loop ;
	
	mov dl,al ; Берем финальный результат деления 
    add dl, 30h ; Преобразуем остаток от деления в ASCII-код символа
    ; Выводим символ на экран
    mov ah, 02h
    int 21h
print_loop2:
	pop dx
	mov dl,dh ; Берем цифру из стека
    add dl, 30h ; Преобразуем остаток от деления в ASCII-код символа
    ; Выводим символ на экран
    mov ah, 02h
    int 21h
	dec bl ;Уменьшаем счетчик
	cmp bl, 1 ; Проверяем, закончили ли вывод
    jns print_loop2 
	


    mov dl, ' ' ; Выводим пробел между числами
    mov ah, 02h
    int 21h

    ; Переходим к следующему элементу массива
    add si, 2 ; Смещаем указатель на размер слова (2 байта)
    loop print_loop
;----------------------------------------------------------------------------
    ; Завершаем программу
	mov ax, 4c00h
    int 21h
;----------------------------------------------------------------------------
main endp
end main
