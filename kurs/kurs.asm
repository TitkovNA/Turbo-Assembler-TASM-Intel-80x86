
;Сортировка строк в текстовом файле


.model small
.stack 100h
.386
.data
;======================Cообщения об ошибках================================
error_open db 13,10, 'Error: Can not open file $'
error_read db 13,10, ' Error: Can not read file $'
error_nullstr db 13,10, ' Error: File have only null string $'
error_create db 13,10, ' Error: Can not create file $'
error_write db 13,10, ' Error: Can not write file $'
error_close db 13,10, ' Error: Can not close file $'
;======================Сообщения об этапах работы программы=============================
message0 db 13,10,'  ',' Kurs. rabota $'
message1 db 13,10,' input file was opened successfully$'
message2 db 13,10,' input file was successfully read$'
message3 db 13,10,' array was created successfully$'
message4 db 13,10,' array has been sorted successfully$'
message5 db 13,10,' output file was created successfully$'
;=====================Переменные для сортировки=================================
filename_input db "INPUT.txt", 0 ; Имя входного файла
filename_output db "OUTPUT.txt",0 ; Имя выходного файла

input_handle dw 0 ; Дескриптор входного файла
output_handle dw 0 ; Дескриптор выходного файла

len_file dw 0 ; Количество символов в файле
lines_count dw 0 ; Количество строк в файле
data_buffer db 5024h DUP(?) ; Данные из файла
lines_buffer dw 128h DUP(?) ; Массив для сортировки с адресами начала строк 
sign_count dw 128h DUP(?) ; Массив количества символов в строках

;=====================Макрос вывода строки================================
print macro message ; message - адрес строки
	mov ah, 09h ; ah - выбор функции 
	lea dx, message ; Адрес строки в dx
	int 21h ; Вызов прерывания
endm
;==========================================================
.code
main:
	mov ax, @data ; Сегмент данных в AX
	mov ds, ax ; Инициализация сегмента данных
	mov es, ax ; Инициализация сегмента доп. данных
;=====================Основное тело программы=================================
print message0 ; Вывод сообщения о начале программы
	call open_file ; Открытие входного файла
print message1; Вывод сообщения об успешном открытии вх. файла
	call read_file ; Чтение вх. файла
print message2 ; Вывод сообщения об успешном чтении вх. файла
	call array_create ; Создание массива адресов начала строк
print message3 ; Вывод сообщения об успешном заполнения вх. файла
	call sort ; Сортировка массива
print message4 ; Вывод сообщения об успешной сортировке
	call create_sign_count ; Создание массива количеста символов в отсортированном массиве 
	call create_file ; Создание выходного файла
	call write_in_outputfile ; Вывод результата сортировки в файл
print message5 ; Вывод сообщения об успешном создании вых. файла
	call exit_prog ; Выход из программы
	
;=====================Открытие входного файла=================================
open_file proc
	mov ah, 3dh ; Функция для открытия файла
	mov al, 0 ; Режим чтения
	lea dx, filename_input ; Передача имени входного файла
	int 21h ; Вызов прерывания. Открываем вх. файл
	jnc pass1 ; Если не было ошибки открытия то идем далее
	print error_open ; Если CF установлен, произошла ошибка - выводим сообщение об ошибке открытия
	call endofprog ; Выход из программы
pass1:
	mov input_handle, ax ; Сохраняем дескриптор файла для чтения
ret
endp
;=====================Чтение информации из вх. файла=================================
read_file proc
	mov ah, 3fh ; Функция для чтения из файла
	mov bx, input_handle ; Дескриптор входного файла
	mov cx, 5024h ; Максимальное количество байт для чтения
	lea dx, data_buffer ; Буфер для чтения данных
	int 21h ; Вызов прерывания. Читаем содержимое вх. файла
	mov len_file, ax ; Сохраняем длину файла
jnc pass2 ; Если не было ошибки чтения то идем далее
	print error_read ; Если CF установлен, произошла ошибка при чтении - выводим сообщение об ошибке чтения
	call exit_prog ; Выход из программы
pass2:
ret
endp
;=====================Создание массива с адресами строк===============================
array_create proc
	push ax ; Сохраняем регистры в стек
	mov ax, len_file ; В ах кол-во прочитанных символов в файле
	or ax,ax ; Проверка на пустой файл
	jnz skip_next ; Если файл не пустой создаем массив
	print error_nullstr ; Если файл пустой - выводим  сообщение об ошибке пустого файла
	call exit_prog ; Выход из программы
skip_next:
	xor bx,bx ; Обнуляем bx
	xor dx,dx ; Обнуляем dx
	lea di,data_buffer ; di - адрес начала данных
	mov lines_buffer[bx],di ; Заносим её адрес начала в массив
	mov al,0Ah ; al - символ конца строки для поиска 
	mov cx,len_file ; сх - всего символов в файле
	cld ; Направление ->
	loop_find:repne scasb ; Сканирование, поиcк заданного символа, пока счетчик не обнулиться, остановиться когда найдет символ 0
	add bx,2 ; Переход на след. символ
	mov lines_buffer[bx],di ;  Помещаем адрес начала новой строки в массив
	inc dx ; dx-кол-во строк
	inc cx ; сх - всего символов в файле
loop loop_find
	mov lines_count, dx ; Сохраняем кол-во строк в lines_count
	mov byte ptr [di],0Dh ; Добавляем символы конца строки
	mov byte ptr [di+1],0Ah ; Добавляем символы конца строки
	pop ax ; Восстанавливаем регистр ax из стека
ret
endp

;=====================Сортировка строк=================================
sort proc
	push ax ; Сохраняем регистры в стек
sort_loop: 
	xor si,si ; Обнуляем si
	mov bh, 0 ; bh - флаг, если строки перемещались, то bh -> 1
	mov cx,lines_count ; сх - кол-во строк в файле
	dec cx ;Если в файле одна строка, то сортировка выполнена
	cmp cx,0
	jnz sort_next ; Если больше переходим к сортировке
	jmp end_sort ; Выход из программы
sort_next:
	xor ax,ax ; Обнуляем ах
	push cx ; Сохраняем сх в стек
	mov ax,lines_buffer[si] ; Адрес начала 1-й строки в ax
	mov dx,lines_buffer[si+2] ; Адрес начала 2-й строки в dx
	push si; Сохраняем si в стек
	mov si,ax ; Адрес начала 1-й строки в ax
	mov di,dx ; Адрес начала 2-й строки в dx
	dec si ; 1-й символ
	dec di ; 1-й символ
compare_string:
	mov cl,byte[si] ; В cl заносим 1-й символ 1-й строки 
	mov ch,byte[di] ; В ch заносим 1-й символ 2-й строки

	cmp cl,0Dh ; Сравниваем символ 1-й строки с симворлом конца строки
	jz next_string ; Если равен 0Dh, переходим к сравнению другой пары строк
	cmp ch,0Dh ; сравниваем символ 2-й строки строки с символом конца строки
	jz change ; Если равен 0Dh -> местами
	cmp cl,ch ; Сравнение символов не из конца строк 
	je next_simbol ; Если равны переход  к сравнению след символа в строках
	cmp cl,ch ; Сравниваем чей порядковый номер больше
	jb next_string ;  Если сl < сh
	jmp change; Иначе меняем строки местами
change:
	xchg ax,dx ; Меняем адреса строк местами
	mov bh,1 ; Устанавливаем флаг что переставновки были
	jmp next_string ; Переход к следующей паре строк 
next_simbol:
	inc si ; Переход к след символу строки
	inc di ; Переход к след символу строки
	jmp compare_string ; Возврат к сравнению строк
next_string:
	pop si ; Восстанавливаем регистр si из стека 
	mov lines_buffer[si],ax ; Заносим адреса отсортированных строк в массив 
	mov lines_buffer[si+2],dx ; Заносим адреса отсортированных строк в массив 
	pop cx ; Восстанавливаем регистр cx из стека
	add si,2 ; Переход к следующей паре строк
loop sort_next
	cmp bh,0 ; Сравниваем флаг на наличие перестановок
	jz end_sort ; Если не было перестановок выходим из сравнения
	jmp sort_loop ; Иначе продолжаем сравнивать
end_sort:
	pop ax ; Восстанавливаем регистр ax из стека
ret
endp

;=====================Создание массива длин отсортированных строк===============================
create_sign_count proc
	push ax ; Сохраняем регистры в стек
	xor si,si ; Обнуляем si
	mov cx, lines_count ; сх - кол-во строк в файле
pass3:
	push cx ; Сохраняем сх в стек
	mov di,lines_buffer[si] ; Адрес начала строки в ax
	push di ; Сохраняем di в стек
	mov al,0Ah ; al - символ конца строки для поиска
	mov cx,len_file ; Количество символов в файле
	cld ; Направление ->
	repne scasb ; Сканирование, поиcк заданного символа, пока счетчик не обнулиться, останоиться когда найдет символ 0Ah
	pop ax ; Восстанавливаем регистр ax из стека
	sub di,ax ; Вычитаем из di начало строки для получения длины строки
	mov sign_count[si],di ; Заносим длину в массив
	add si,2 ; организация перехода к след элементу
	pop cx ; Восстанавливаем регистр сx из стека
loop pass3
	pop ax ; Восстанавливаем регистр ax из стека
ret
endp
;=====================Создание выходного файла для записи результата=============================
create_file proc
	mov ah, 3ch ; Функция для создания файла
	mov cx, 00h ; Режим создания/записи
	lea dx, filename_output ; Передача имени выходного файла
	int 21h ; Вызов прерывания. Создаем вых. файл
jnc pass4 ; Если не было ошибки создания то идем далее
	print error_create ; Если CF установлен, произошла ошибка создание - выводим сообщение об ошибке создания
	call exit_prog ; Выход из программы
pass4:
	mov output_handle, ax ; Сохраняем дескриптор выходного файла
ret
endp
;=====================Запись резульатата в выходной файл===============================
write_in_outputfile proc
	xor si,si ; Обнуляем si
	mov cx, lines_count ; сх - кол-во строк в файле
pass5:
	push cx ; Сохраняем cx в стек
	mov ah,40h ; Функция для записи в файл
	mov bx, output_handle ; Дескриптор выходного файла
	mov cx,sign_count[si] ; Количество символов которые надо записать в файл
	mov dx,lines_buffer[si] ; Символы
	int 21h ; Вызов прерывания. Запись в файл
jnc pass6 ; Если не было ошибки создания то идем далее
	print error_write ; Если CF установлен, произошла ошибка записи - выводим сообщение об ошибки записи
	call exit_prog ; Выход из программы
pass6:
	add si,2 ; переход к следующей строке
	pop cx ; Восстанавливаем регистр сx из стека
loop pass5
ret
endp
;=====================Закрытие файлов=================================
close_file proc
	cmp input_handle, 0 ; Проверяем на пустой файл
	je pass7 ; Если пустой то выводить нечего, переходим на выход
	mov ah, 3eh ; Функция для закрытия файла
	mov bx, input_handle ; Дескриптор входного файла
	int 21h ; Вызов прерывания. Закрытие файла
	jnc pass7 ; Если не было ошибки создания то идем далее
	print error_close ; Если CF установлен, произошла ошибка закрытия - выводим сообщение об ошибки закрытия
	call exit_prog ; Выход из программы
pass7:
	cmp output_handle, 0 ; Проверяем на пустой файл
	je pass8 ; Если пустой то закрывать нечего, ппереходим на выход
	mov ah, 3eh ; Функция для закрытия файла
	mov bx, output_handle ; Дескриптор выходного файла
	int 21h ; Вызов прерывания. Закрытие файла
	jnc pass8 ; Если не было ошибки создания то идем далее
	print error_close ; Если CF установлен, произошла ошибка закрытия - выводим сообщение об ошибки закрытия
	call exit_prog ; Выход из программы
pass8:
ret
endp
;=====================Выход из программы=================================
exit_prog proc 
	call close_file ; Закрытие файлов
endofprog:
	mov ax, 4c00h ; Завершение программы с кодом возврата 0
	int 21h ; Вызов прерывания. Выход из программы
ret
endp

End main 